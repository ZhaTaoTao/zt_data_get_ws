# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from fixposition_driver_ros1/odomstatus.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import std_msgs.msg

class odomstatus(genpy.Message):
  _md5sum = "307cfe184ec2b75acdc3f76049315683"
  _type = "fixposition_driver_ros1/odomstatus"
  _has_header = True  # flag to mark the presence of a Header object
  _full_text = """####################################################################################################
#
#    Copyright (c) 2023  ___     ___
#                       \\  \\  /  /
#                        \\  \\/  /
#                         /  /\\  \\
#                        /__/  \\__\\  Fixposition AG
#
####################################################################################################
#
# Fixposition FP_A-ODOMSTATUS Message
#
#
####################################################################################################

Header header
int16 init_status                            # Fusion init status (see below)
int16 fusion_imu                             # Fusion measurement status: IMU (see below)
int16 fusion_gnss1                           # Fusion measurement status: GNSS 1 (see below)
int16 fusion_gnss2                           # Fusion measurement status: GNSS 2 (see below)
int16 fusion_corr                            # Fusion measurement status: GNSS corrections (see below)
int16 fusion_cam1                            # Fusion measurement status: camera (see below)
int16 fusion_ws                              # Fusion measurement status: wheelspeed (see below)
int16 fusion_markers                         # Fusion measurement status: markers (see below)
int16 imu_status                             # IMU bias status (see below)
int16 imu_noise                              # IMU variance status (see below)
int16 imu_conv                               # IMU convergence status (see below)
int16 gnss1_status                           # GNSS 1 status (see below)
int16 gnss2_status                           # GNSS 2 status (see below)
int16 baseline_status                        # Baseline status (see below)
int16 corr_status                            # GNSS correction status (see below)
int16 cam1_status                            # Camera 1 status (see below)
int16 ws_status                              # Wheelspeed status (see below)
int16 ws_conv                                # Wheelspeed convergence status (see below)
int16 markers_status                         # Markers status (see below)
int16 markers_conv                           # Markers convergence status (see below)


# Fusion initialisation status (init_status)
#
# | Value | Description          |
# |-------|----------------------|
# |  null | Unknown              |
# |   0   | Not initialized      |
# |   1   | Locally initialised  |
# |   2   | Globally initialised |


# Fusion measurement status (fusion_imu, fusion_cam1, fusion_cam2, fusion_gnss1, fusion_gnss2, fusion_corr, fusion_ws, fusion_markers)
#
# | Value | Description        |
# |-------|--------------------|
# |  null | Info not available |
# |   0   | Not used           |
# |   1   | Used               |
# |   2   | Degraded           |


# IMU bias status (imu_status)
#
# | Value | Description        |
# |-------|--------------------|
# |  null | Info not available |
# |   0   | Not converged      |
# |   1   | Warmstarted        |
# |   2   | Rough convergence  |
# |   3   | Fine convergence   |


# IMU variance (imu_noise)
#
# | Value | Description        |
# |-------|--------------------|
# |  null | Info not available |
# |   0   | Reserved           |
# |   1   | Low noise          |
# |   2   | Medium noise       |
# |   3   | High noise         |
# | 4...7 | Reserved           |


# IMU accelerometer and gyroscope convergence (imu_conv)
#
# | Value | Description                      |
# |-------|----------------------------------|
# |  null | Info not available               |
# |   0   | Awaiting Fusion                  |
# |   1   | Awaiting IMU measurements        |
# |   2   | Insufficient global measurements |
# |   3   | Insufficient motion              |
# |   4   | Converging                       |
# | 5...6 | Reserved                         |
# |   7   | Idle                             |


# GNSS fix status (gnss1_status, gnss2_status)
#
# | Value | Description                    |
# |-------|--------------------------------|
# |  null | Info not available             |
# |   0   | No fix                         |
# |   1   | Single-point positioning (SPP) |
# |   2   | RTK moving baseline            |
# | 3...4 | Reserved                       |
# |   5   | RTK float                      |
# | 6...7 | Reserved                       |
# |   8   | RTK fixed                      |


# GNSS correction status (corr_status)
#
# | Value | Description                                                                                                    |
# |-------|----------------------------------------------------------------------------------------------------------------|
# |  null | Info not available                                                                                             |
# |   0   | Waiting fusion                                                                                                 |
# |   1   | No GNSS available                                                                                              |
# |   2   | No corrections used                                                                                            |
# |   3   | Limited corrections used: station data & at least one of the constellations among the valid rover measurements |
# |   4   | Corrections are too old                                                                                        |
# |   5   | Sufficient corrections used: station data and corrections for ALL bands among the valid rover measurements     |


# Baseline status (baseline_status)
#
# | Value | Description            |
# |-------|------------------------|
# |  null | Info not available     |
# |   0   | Waiting fusion         |
# |   1   | Not available / No fix |
# |   2   | Failing                |
# |   3   | Passing                |


# Camera status (cam1_status)
#
# | Value | Description                                      |
# |-------|--------------------------------------------------|
# |  null | Info not available                               |
# |   0   | Camera not available                             |
# |   1   | Camera available, but not usable (e.g. too dark) |
# | 2...4 | Reserved                                         |
# |   5   | Camera working and available                     |


# Wheelspeed status (ws_status)
#
# | Value | Description                                                |
# |-------|------------------------------------------------------------|
# |  null | Info not available                                         |
# |   0   | No wheelspeed enabled                                      |
# |   1   | Missing wheelspeed measurements                            |
# |   2   | At least one wheelspeed enabled, no wheelspeed converged   |
# |   3   | At least one wheelspeed enabled and at least one converged |
# |   4   | At least one wheelspeed enabled and all converged          |


# Wheelspeed convergence status (ws_conv)
#
# | Value | Description                       |
# |-------|-----------------------------------|
# |  null | Info not available                |
# |   0   | Awaiting Fusion                   |
# |   1   | Missing wheelspeed measurements   |
# |   2   | Insufficient global measurements  |
# |   3   | Insufficient motion               |
# |   4   | Insufficient imu bias convergence |
# |   5   | Converging                        |
# |   6   | Idle                              |


# Markers status (markers_status)
#
# | Value | Description                 |
# |-------|-----------------------------|
# |  null | Info not available          |
# |   0   | No markers available        |
# |   1   | Markers available           |
# |   2   | Markers available, and used |


# Markers convergence status (markers_conv)
#
# | Value | Description                      |
# |-------|----------------------------------|
# |  null | Info not available               |
# |   0   | Awaiting Fusion                  |
# |   1   | Waiting marker measurements      |
# |   2   | Insufficient global measurements |
# |   3   | Converging                       |
# |   4   | Idle                             |

================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id
"""
  __slots__ = ['header','init_status','fusion_imu','fusion_gnss1','fusion_gnss2','fusion_corr','fusion_cam1','fusion_ws','fusion_markers','imu_status','imu_noise','imu_conv','gnss1_status','gnss2_status','baseline_status','corr_status','cam1_status','ws_status','ws_conv','markers_status','markers_conv']
  _slot_types = ['std_msgs/Header','int16','int16','int16','int16','int16','int16','int16','int16','int16','int16','int16','int16','int16','int16','int16','int16','int16','int16','int16','int16']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,init_status,fusion_imu,fusion_gnss1,fusion_gnss2,fusion_corr,fusion_cam1,fusion_ws,fusion_markers,imu_status,imu_noise,imu_conv,gnss1_status,gnss2_status,baseline_status,corr_status,cam1_status,ws_status,ws_conv,markers_status,markers_conv

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(odomstatus, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.init_status is None:
        self.init_status = 0
      if self.fusion_imu is None:
        self.fusion_imu = 0
      if self.fusion_gnss1 is None:
        self.fusion_gnss1 = 0
      if self.fusion_gnss2 is None:
        self.fusion_gnss2 = 0
      if self.fusion_corr is None:
        self.fusion_corr = 0
      if self.fusion_cam1 is None:
        self.fusion_cam1 = 0
      if self.fusion_ws is None:
        self.fusion_ws = 0
      if self.fusion_markers is None:
        self.fusion_markers = 0
      if self.imu_status is None:
        self.imu_status = 0
      if self.imu_noise is None:
        self.imu_noise = 0
      if self.imu_conv is None:
        self.imu_conv = 0
      if self.gnss1_status is None:
        self.gnss1_status = 0
      if self.gnss2_status is None:
        self.gnss2_status = 0
      if self.baseline_status is None:
        self.baseline_status = 0
      if self.corr_status is None:
        self.corr_status = 0
      if self.cam1_status is None:
        self.cam1_status = 0
      if self.ws_status is None:
        self.ws_status = 0
      if self.ws_conv is None:
        self.ws_conv = 0
      if self.markers_status is None:
        self.markers_status = 0
      if self.markers_conv is None:
        self.markers_conv = 0
    else:
      self.header = std_msgs.msg.Header()
      self.init_status = 0
      self.fusion_imu = 0
      self.fusion_gnss1 = 0
      self.fusion_gnss2 = 0
      self.fusion_corr = 0
      self.fusion_cam1 = 0
      self.fusion_ws = 0
      self.fusion_markers = 0
      self.imu_status = 0
      self.imu_noise = 0
      self.imu_conv = 0
      self.gnss1_status = 0
      self.gnss2_status = 0
      self.baseline_status = 0
      self.corr_status = 0
      self.cam1_status = 0
      self.ws_status = 0
      self.ws_conv = 0
      self.markers_status = 0
      self.markers_conv = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_20h().pack(_x.init_status, _x.fusion_imu, _x.fusion_gnss1, _x.fusion_gnss2, _x.fusion_corr, _x.fusion_cam1, _x.fusion_ws, _x.fusion_markers, _x.imu_status, _x.imu_noise, _x.imu_conv, _x.gnss1_status, _x.gnss2_status, _x.baseline_status, _x.corr_status, _x.cam1_status, _x.ws_status, _x.ws_conv, _x.markers_status, _x.markers_conv))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 40
      (_x.init_status, _x.fusion_imu, _x.fusion_gnss1, _x.fusion_gnss2, _x.fusion_corr, _x.fusion_cam1, _x.fusion_ws, _x.fusion_markers, _x.imu_status, _x.imu_noise, _x.imu_conv, _x.gnss1_status, _x.gnss2_status, _x.baseline_status, _x.corr_status, _x.cam1_status, _x.ws_status, _x.ws_conv, _x.markers_status, _x.markers_conv,) = _get_struct_20h().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_20h().pack(_x.init_status, _x.fusion_imu, _x.fusion_gnss1, _x.fusion_gnss2, _x.fusion_corr, _x.fusion_cam1, _x.fusion_ws, _x.fusion_markers, _x.imu_status, _x.imu_noise, _x.imu_conv, _x.gnss1_status, _x.gnss2_status, _x.baseline_status, _x.corr_status, _x.cam1_status, _x.ws_status, _x.ws_conv, _x.markers_status, _x.markers_conv))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 40
      (_x.init_status, _x.fusion_imu, _x.fusion_gnss1, _x.fusion_gnss2, _x.fusion_corr, _x.fusion_cam1, _x.fusion_ws, _x.fusion_markers, _x.imu_status, _x.imu_noise, _x.imu_conv, _x.gnss1_status, _x.gnss2_status, _x.baseline_status, _x.corr_status, _x.cam1_status, _x.ws_status, _x.ws_conv, _x.markers_status, _x.markers_conv,) = _get_struct_20h().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_20h = None
def _get_struct_20h():
    global _struct_20h
    if _struct_20h is None:
        _struct_20h = struct.Struct("<20h")
    return _struct_20h
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
