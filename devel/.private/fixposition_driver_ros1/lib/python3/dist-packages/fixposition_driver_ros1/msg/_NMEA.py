# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from fixposition_driver_ros1/NMEA.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import fixposition_driver_ros1.msg
import std_msgs.msg

class NMEA(genpy.Message):
  _md5sum = "ec17f8d2bc98980ffc7004f565692fa0"
  _type = "fixposition_driver_ros1/NMEA"
  _has_header = True  # flag to mark the presence of a Header object
  _full_text = """####################################################################################################
#
#    Copyright (c) 2023  ___     ___
#                       \\  \\  /  /
#                        \\  \\/  /
#                         /  /\\  \\
#                        /__/  \\__\\  Fixposition AG
#
####################################################################################################
#
# Fixposition NMEA Message. Specified using the WGS 84 reference ellipsoid.
#
#
####################################################################################################

# Format  | Field       | Unit              | Description
# --------|-------------|-------------------|----------------------------------------------------------------------|
Header      header      # [ns]              | Specifies the ROS time and Euclidian reference frame.
string      time        # [hhmmss.ss(ss)]   | UTC time (hours, minutes and seconds).
string      date        # [ddmmyy]          | UTC date (day, month and year).
float64     latitude    # [ddmm.mmmmm(mm)]  | Latitude. Positive is north of equator; negative is south.
float64     longitude   # [dddmm.mmmmm(mm)] | Longitude. Positive is east of prime meridian; negative is west.
float64     altitude    # [m]               | Altitude. Positive is above the WGS 84 ellipsoid.
int8        quality     # [-]               | Quality indicator (see below).
int8        num_sv      # [-]               | Number of satellites. Strict NMEA: 00-12. High-precision NMEA: 00-99.
int8[]      ids         # [-]               | ID numbers of satellites used in solution. See the NMEA 0183 version 4.11 standard document.
float64     hdop_rec    # [0.10-99.99]      | Horizontal dilution of precision.
float64     pdop        # [-]               | Position dillution of precision.
float64     hdop        # [-]               | Horizontal dillution of precision.
float64     vdop        # [-]               | Vertical dillution of precision.
float64     rms_range   # [-]               | RMS value of the standard deviation of the range inputs to the navigation process.
float64     std_major   # [m]               | Standard deviation of semi-major axis of error ellipse.
float64     std_minor   # [m]               | Standard deviation of semi-minor axis of error ellipse.
float64     angle_major # [deg]             | Angle of semi-major axis of error ellipse from true North.
float64     std_lat     # [m]               | Standard deviation of latitude error.
float64     std_lon     # [m]               | Standard deviation of longitude error.
float64     std_alt     # [m]               | Standard deviation of altitude error.
float64[9]  covariance  # [m2]              | Position covariance defined relative to a tangential plane (ENU frame).
int8        cov_type    # [-]               | Method employed to estimate covariance (see below).
float64     heading     # [deg]             | True heading.
float64     speed       # [m/s]             | Speed over ground.
float64     course      # [deg]             | Course over ground (w.r.t. True North).
float64     diff_age    # [-]               | Approximate age of differential data (last GPS MSM message received).
string      diff_sta    # [-]               | DGPS station ID (0000-1023).
fixposition_driver_ros1/GnssSats[] gnss_sats # [-]| GNSS satellite signal statistics.

# Quality indicator table
#
# | ID | Signal         |
# |----|----------------|
# |  0 | Invalid        |
# |  1 | Non-RTK fix    |
# |  4 | RTK fixed      |
# |  5 | RTK float      |
# |  6 | Dead-reckoning |


# Covariance type table
#
# | ID | Signal         |
# |----|----------------|
# |  0 | Unknown        |
# |  1 | Approximated   |
# |  2 | Diagonal known |
# |  3 | Known          |

================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id

================================================================================
MSG: fixposition_driver_ros1/GnssSats
####################################################################################################
#
#    Copyright (c) 2023  ___     ___
#                       \\  \\  /  /
#                        \\  \\/  /
#                         /  /\\  \\
#                        /__/  \\__\\  Fixposition AG
#
####################################################################################################
#
# Fixposition GNSS satellite signal statistics message.
#
#
####################################################################################################

# Format | Field         | Unit    | Description
# -------|---------------|---------|------------------------------------|
string     constellation # [Hex]   | Signal ID (see below).
int16[]    sat_id        # [-]     | Satellite ID number.
int16[]    azim          # [deg]   | Satellite azimuth from true North.
int16[]    elev          # [deg]   | Satellite elevation.
int16[]    cno_l1        # [db-Hz] | Satellite SNR (C/No) for L1-band.
int16[]    cno_l2        # [db-Hz] | Satellite SNR (C/No) for L2-band.
"""
  __slots__ = ['header','time','date','latitude','longitude','altitude','quality','num_sv','ids','hdop_rec','pdop','hdop','vdop','rms_range','std_major','std_minor','angle_major','std_lat','std_lon','std_alt','covariance','cov_type','heading','speed','course','diff_age','diff_sta','gnss_sats']
  _slot_types = ['std_msgs/Header','string','string','float64','float64','float64','int8','int8','int8[]','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64','float64[9]','int8','float64','float64','float64','float64','string','fixposition_driver_ros1/GnssSats[]']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,time,date,latitude,longitude,altitude,quality,num_sv,ids,hdop_rec,pdop,hdop,vdop,rms_range,std_major,std_minor,angle_major,std_lat,std_lon,std_alt,covariance,cov_type,heading,speed,course,diff_age,diff_sta,gnss_sats

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(NMEA, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.time is None:
        self.time = ''
      if self.date is None:
        self.date = ''
      if self.latitude is None:
        self.latitude = 0.
      if self.longitude is None:
        self.longitude = 0.
      if self.altitude is None:
        self.altitude = 0.
      if self.quality is None:
        self.quality = 0
      if self.num_sv is None:
        self.num_sv = 0
      if self.ids is None:
        self.ids = []
      if self.hdop_rec is None:
        self.hdop_rec = 0.
      if self.pdop is None:
        self.pdop = 0.
      if self.hdop is None:
        self.hdop = 0.
      if self.vdop is None:
        self.vdop = 0.
      if self.rms_range is None:
        self.rms_range = 0.
      if self.std_major is None:
        self.std_major = 0.
      if self.std_minor is None:
        self.std_minor = 0.
      if self.angle_major is None:
        self.angle_major = 0.
      if self.std_lat is None:
        self.std_lat = 0.
      if self.std_lon is None:
        self.std_lon = 0.
      if self.std_alt is None:
        self.std_alt = 0.
      if self.covariance is None:
        self.covariance = [0.] * 9
      if self.cov_type is None:
        self.cov_type = 0
      if self.heading is None:
        self.heading = 0.
      if self.speed is None:
        self.speed = 0.
      if self.course is None:
        self.course = 0.
      if self.diff_age is None:
        self.diff_age = 0.
      if self.diff_sta is None:
        self.diff_sta = ''
      if self.gnss_sats is None:
        self.gnss_sats = []
    else:
      self.header = std_msgs.msg.Header()
      self.time = ''
      self.date = ''
      self.latitude = 0.
      self.longitude = 0.
      self.altitude = 0.
      self.quality = 0
      self.num_sv = 0
      self.ids = []
      self.hdop_rec = 0.
      self.pdop = 0.
      self.hdop = 0.
      self.vdop = 0.
      self.rms_range = 0.
      self.std_major = 0.
      self.std_minor = 0.
      self.angle_major = 0.
      self.std_lat = 0.
      self.std_lon = 0.
      self.std_alt = 0.
      self.covariance = [0.] * 9
      self.cov_type = 0
      self.heading = 0.
      self.speed = 0.
      self.course = 0.
      self.diff_age = 0.
      self.diff_sta = ''
      self.gnss_sats = []

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.time
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.date
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_3d2b().pack(_x.latitude, _x.longitude, _x.altitude, _x.quality, _x.num_sv))
      length = len(self.ids)
      buff.write(_struct_I.pack(length))
      pattern = '<%sb'%length
      buff.write(struct.Struct(pattern).pack(*self.ids))
      _x = self
      buff.write(_get_struct_11d().pack(_x.hdop_rec, _x.pdop, _x.hdop, _x.vdop, _x.rms_range, _x.std_major, _x.std_minor, _x.angle_major, _x.std_lat, _x.std_lon, _x.std_alt))
      buff.write(_get_struct_9d().pack(*self.covariance))
      _x = self
      buff.write(_get_struct_b4d().pack(_x.cov_type, _x.heading, _x.speed, _x.course, _x.diff_age))
      _x = self.diff_sta
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      length = len(self.gnss_sats)
      buff.write(_struct_I.pack(length))
      for val1 in self.gnss_sats:
        _x = val1.constellation
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        length = len(val1.sat_id)
        buff.write(_struct_I.pack(length))
        pattern = '<%sh'%length
        buff.write(struct.Struct(pattern).pack(*val1.sat_id))
        length = len(val1.azim)
        buff.write(_struct_I.pack(length))
        pattern = '<%sh'%length
        buff.write(struct.Struct(pattern).pack(*val1.azim))
        length = len(val1.elev)
        buff.write(_struct_I.pack(length))
        pattern = '<%sh'%length
        buff.write(struct.Struct(pattern).pack(*val1.elev))
        length = len(val1.cno_l1)
        buff.write(_struct_I.pack(length))
        pattern = '<%sh'%length
        buff.write(struct.Struct(pattern).pack(*val1.cno_l1))
        length = len(val1.cno_l2)
        buff.write(_struct_I.pack(length))
        pattern = '<%sh'%length
        buff.write(struct.Struct(pattern).pack(*val1.cno_l2))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.gnss_sats is None:
        self.gnss_sats = None
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.time = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.time = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.date = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.date = str[start:end]
      _x = self
      start = end
      end += 26
      (_x.latitude, _x.longitude, _x.altitude, _x.quality, _x.num_sv,) = _get_struct_3d2b().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sb'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.ids = s.unpack(str[start:end])
      _x = self
      start = end
      end += 88
      (_x.hdop_rec, _x.pdop, _x.hdop, _x.vdop, _x.rms_range, _x.std_major, _x.std_minor, _x.angle_major, _x.std_lat, _x.std_lon, _x.std_alt,) = _get_struct_11d().unpack(str[start:end])
      start = end
      end += 72
      self.covariance = _get_struct_9d().unpack(str[start:end])
      _x = self
      start = end
      end += 33
      (_x.cov_type, _x.heading, _x.speed, _x.course, _x.diff_age,) = _get_struct_b4d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.diff_sta = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.diff_sta = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.gnss_sats = []
      for i in range(0, length):
        val1 = fixposition_driver_ros1.msg.GnssSats()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.constellation = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.constellation = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sh'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.sat_id = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sh'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.azim = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sh'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.elev = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sh'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.cno_l1 = s.unpack(str[start:end])
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sh'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.cno_l2 = s.unpack(str[start:end])
        self.gnss_sats.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.time
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.date
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_3d2b().pack(_x.latitude, _x.longitude, _x.altitude, _x.quality, _x.num_sv))
      length = len(self.ids)
      buff.write(_struct_I.pack(length))
      pattern = '<%sb'%length
      buff.write(self.ids.tostring())
      _x = self
      buff.write(_get_struct_11d().pack(_x.hdop_rec, _x.pdop, _x.hdop, _x.vdop, _x.rms_range, _x.std_major, _x.std_minor, _x.angle_major, _x.std_lat, _x.std_lon, _x.std_alt))
      buff.write(self.covariance.tostring())
      _x = self
      buff.write(_get_struct_b4d().pack(_x.cov_type, _x.heading, _x.speed, _x.course, _x.diff_age))
      _x = self.diff_sta
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      length = len(self.gnss_sats)
      buff.write(_struct_I.pack(length))
      for val1 in self.gnss_sats:
        _x = val1.constellation
        length = len(_x)
        if python3 or type(_x) == unicode:
          _x = _x.encode('utf-8')
          length = len(_x)
        buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
        length = len(val1.sat_id)
        buff.write(_struct_I.pack(length))
        pattern = '<%sh'%length
        buff.write(val1.sat_id.tostring())
        length = len(val1.azim)
        buff.write(_struct_I.pack(length))
        pattern = '<%sh'%length
        buff.write(val1.azim.tostring())
        length = len(val1.elev)
        buff.write(_struct_I.pack(length))
        pattern = '<%sh'%length
        buff.write(val1.elev.tostring())
        length = len(val1.cno_l1)
        buff.write(_struct_I.pack(length))
        pattern = '<%sh'%length
        buff.write(val1.cno_l1.tostring())
        length = len(val1.cno_l2)
        buff.write(_struct_I.pack(length))
        pattern = '<%sh'%length
        buff.write(val1.cno_l2.tostring())
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.gnss_sats is None:
        self.gnss_sats = None
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.time = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.time = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.date = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.date = str[start:end]
      _x = self
      start = end
      end += 26
      (_x.latitude, _x.longitude, _x.altitude, _x.quality, _x.num_sv,) = _get_struct_3d2b().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sb'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.ids = numpy.frombuffer(str[start:end], dtype=numpy.int8, count=length)
      _x = self
      start = end
      end += 88
      (_x.hdop_rec, _x.pdop, _x.hdop, _x.vdop, _x.rms_range, _x.std_major, _x.std_minor, _x.angle_major, _x.std_lat, _x.std_lon, _x.std_alt,) = _get_struct_11d().unpack(str[start:end])
      start = end
      end += 72
      self.covariance = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=9)
      _x = self
      start = end
      end += 33
      (_x.cov_type, _x.heading, _x.speed, _x.course, _x.diff_age,) = _get_struct_b4d().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.diff_sta = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.diff_sta = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      self.gnss_sats = []
      for i in range(0, length):
        val1 = fixposition_driver_ros1.msg.GnssSats()
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        start = end
        end += length
        if python3:
          val1.constellation = str[start:end].decode('utf-8', 'rosmsg')
        else:
          val1.constellation = str[start:end]
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sh'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.sat_id = numpy.frombuffer(str[start:end], dtype=numpy.int16, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sh'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.azim = numpy.frombuffer(str[start:end], dtype=numpy.int16, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sh'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.elev = numpy.frombuffer(str[start:end], dtype=numpy.int16, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sh'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.cno_l1 = numpy.frombuffer(str[start:end], dtype=numpy.int16, count=length)
        start = end
        end += 4
        (length,) = _struct_I.unpack(str[start:end])
        pattern = '<%sh'%length
        start = end
        s = struct.Struct(pattern)
        end += s.size
        val1.cno_l2 = numpy.frombuffer(str[start:end], dtype=numpy.int16, count=length)
        self.gnss_sats.append(val1)
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_11d = None
def _get_struct_11d():
    global _struct_11d
    if _struct_11d is None:
        _struct_11d = struct.Struct("<11d")
    return _struct_11d
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
_struct_3d2b = None
def _get_struct_3d2b():
    global _struct_3d2b
    if _struct_3d2b is None:
        _struct_3d2b = struct.Struct("<3d2b")
    return _struct_3d2b
_struct_9d = None
def _get_struct_9d():
    global _struct_9d
    if _struct_9d is None:
        _struct_9d = struct.Struct("<9d")
    return _struct_9d
_struct_b4d = None
def _get_struct_b4d():
    global _struct_b4d
    if _struct_b4d is None:
        _struct_b4d = struct.Struct("<b4d")
    return _struct_b4d
