// Generated by gencpp from file fixposition_driver_ros1/tp.msg
// DO NOT EDIT!


#ifndef FIXPOSITION_DRIVER_ROS1_MESSAGE_TP_H
#define FIXPOSITION_DRIVER_ROS1_MESSAGE_TP_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace fixposition_driver_ros1
{
template <class ContainerAllocator>
struct tp_
{
  typedef tp_<ContainerAllocator> Type;

  tp_()
    : tp_name()
    , timebase()
    , timeref()
    , tp_tow_sec(0)
    , tp_tow_psec(0.0)
    , gps_leaps(0)  {
    }
  tp_(const ContainerAllocator& _alloc)
    : tp_name(_alloc)
    , timebase(_alloc)
    , timeref(_alloc)
    , tp_tow_sec(0)
    , tp_tow_psec(0.0)
    , gps_leaps(0)  {
  (void)_alloc;
    }



   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _tp_name_type;
  _tp_name_type tp_name;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _timebase_type;
  _timebase_type timebase;

   typedef std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>> _timeref_type;
  _timeref_type timeref;

   typedef int64_t _tp_tow_sec_type;
  _tp_tow_sec_type tp_tow_sec;

   typedef double _tp_tow_psec_type;
  _tp_tow_psec_type tp_tow_psec;

   typedef int64_t _gps_leaps_type;
  _gps_leaps_type gps_leaps;





  typedef boost::shared_ptr< ::fixposition_driver_ros1::tp_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::fixposition_driver_ros1::tp_<ContainerAllocator> const> ConstPtr;

}; // struct tp_

typedef ::fixposition_driver_ros1::tp_<std::allocator<void> > tp;

typedef boost::shared_ptr< ::fixposition_driver_ros1::tp > tpPtr;
typedef boost::shared_ptr< ::fixposition_driver_ros1::tp const> tpConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::fixposition_driver_ros1::tp_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::fixposition_driver_ros1::tp_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::fixposition_driver_ros1::tp_<ContainerAllocator1> & lhs, const ::fixposition_driver_ros1::tp_<ContainerAllocator2> & rhs)
{
  return lhs.tp_name == rhs.tp_name &&
    lhs.timebase == rhs.timebase &&
    lhs.timeref == rhs.timeref &&
    lhs.tp_tow_sec == rhs.tp_tow_sec &&
    lhs.tp_tow_psec == rhs.tp_tow_psec &&
    lhs.gps_leaps == rhs.gps_leaps;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::fixposition_driver_ros1::tp_<ContainerAllocator1> & lhs, const ::fixposition_driver_ros1::tp_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace fixposition_driver_ros1

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::fixposition_driver_ros1::tp_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::fixposition_driver_ros1::tp_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::fixposition_driver_ros1::tp_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::fixposition_driver_ros1::tp_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::fixposition_driver_ros1::tp_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::fixposition_driver_ros1::tp_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::fixposition_driver_ros1::tp_<ContainerAllocator> >
{
  static const char* value()
  {
    return "fb47e0dd4a2fae13d470d2c34ba242f0";
  }

  static const char* value(const ::fixposition_driver_ros1::tp_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xfb47e0dd4a2fae13ULL;
  static const uint64_t static_value2 = 0xd470d2c34ba242f0ULL;
};

template<class ContainerAllocator>
struct DataType< ::fixposition_driver_ros1::tp_<ContainerAllocator> >
{
  static const char* value()
  {
    return "fixposition_driver_ros1/tp";
  }

  static const char* value(const ::fixposition_driver_ros1::tp_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::fixposition_driver_ros1::tp_<ContainerAllocator> >
{
  static const char* value()
  {
    return "####################################################################################################\n"
"#\n"
"#    Copyright (c) 2023  ___     ___\n"
"#                       \\\\  \\\\  /  /\n"
"#                        \\\\  \\\\/  /\n"
"#                         /  /\\\\  \\\\\n"
"#                        /__/  \\\\__\\\\  Fixposition AG\n"
"#\n"
"####################################################################################################\n"
"#\n"
"# Fixposition FP_A-TP Message\n"
"#\n"
"#\n"
"####################################################################################################\n"
"\n"
"string  tp_name                              # Timepulse name (source)\n"
"string  timebase                             # Time base (see below), or null if not available\n"
"string  timeref                              # Time reference (see below), or null if not available\n"
"int64   tp_tow_sec                           # Timepulse time seconds of week, integer second part (0–604799), or null\n"
"float64 tp_tow_psec                          # Timepulse time seconds of week, sub-second part (0.000000000000–0.999999999999), or null\n"
"int64   gps_leaps                            # GPS leapseconds, or null if unknown\n"
"\n"
"\n"
"# Values for timebase\n"
"#\n"
"# | Value | Description               |\n"
"# |-------|---------------------------|\n"
"# |  null | No timepulse alignment    |\n"
"# |  GNSS | Timepulse aligned to GNSS |\n"
"# |   UTC | Timepulse aligned to UTC  |\n"
"\n"
"\n"
"# Values for timeref if timebase is GNSS\n"
"#\n"
"# | Value | Description                     |\n"
"# |-------|---------------------------------|\n"
"# |   GPS | Timepulse aligned to GPS        |\n"
"# |   GAL | Timepulse aligned to Galileo    |\n"
"# |   BDS | Timepulse aligned to BeiDou     |\n"
"# |   GLO | Timepulse aligned to GLONASS    |\n"
"# | OTHER | Timepulse aligned to other GNSS |\n"
"\n"
"\n"
"# Values for timeref if timebase is UTC\n"
"#\n"
"# | Value | Description                                                                |\n"
"# |-------|----------------------------------------------------------------------------|\n"
"# |  NONE | Timepulse aligned to no UTC (no precise UTC parameters known yet)          |\n"
"# |   CRL | Timepulse aligned to Communications Research Laboratory (CRL), Japan       |\n"
"# |  NIST | Timepulse aligned to National Institute of Standards and Technology (NIST) |\n"
"# |  USNO | Timepulse aligned to U.S. Naval Observatory (USNO)                         |\n"
"# |  BIPM | Timepulse aligned to International Bureau of Weights and Measures (BIPM)   |\n"
"# |    EU | Timepulse aligned to European laboratories                                 |\n"
"# |    SU | Timepulse aligned to Former Soviet Union (SU)                              |\n"
"# |  NTSC | Timepulse aligned to National Time Service Center (NTSC), China            |\n"
"# | OTHER | Timepulse aligned to other/unknown UTC                                     |\n"
;
  }

  static const char* value(const ::fixposition_driver_ros1::tp_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::fixposition_driver_ros1::tp_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.tp_name);
      stream.next(m.timebase);
      stream.next(m.timeref);
      stream.next(m.tp_tow_sec);
      stream.next(m.tp_tow_psec);
      stream.next(m.gps_leaps);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct tp_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::fixposition_driver_ros1::tp_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::fixposition_driver_ros1::tp_<ContainerAllocator>& v)
  {
    s << indent << "tp_name: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.tp_name);
    s << indent << "timebase: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.timebase);
    s << indent << "timeref: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename std::allocator_traits<ContainerAllocator>::template rebind_alloc<char>>>::stream(s, indent + "  ", v.timeref);
    s << indent << "tp_tow_sec: ";
    Printer<int64_t>::stream(s, indent + "  ", v.tp_tow_sec);
    s << indent << "tp_tow_psec: ";
    Printer<double>::stream(s, indent + "  ", v.tp_tow_psec);
    s << indent << "gps_leaps: ";
    Printer<int64_t>::stream(s, indent + "  ", v.gps_leaps);
  }
};

} // namespace message_operations
} // namespace ros

#endif // FIXPOSITION_DRIVER_ROS1_MESSAGE_TP_H
